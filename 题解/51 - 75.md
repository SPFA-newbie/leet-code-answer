## #51 N皇后

> [题目描述](https://leetcode.cn/problems/n-queens/)

经典的回溯问题，递归地尝试在新的一行的每个格子中放入皇后，将全部N个皇后置入棋盘后则得到了一种可行解。

时间复杂度为$O(N!)$，其中$N$是皇后的数量。



## #52 N皇后 II 

> [题目描述](https://leetcode.cn/problems/n-queens-ii/)

思路与上一题完全一致。



## #55 跳跃游戏

> [题目描述](https://leetcode.cn/problems/jump-game/)

**朴素解法**

设置一个布尔数组`arr`记录能够到达的位置，每到达一个能够到达的位置，寻找这个位置能够到达的新的位置并使用`arr`记录。

时间复杂度为$O(n^{2})$，$n$是序列的长度，另外，还需要$O(n)$的额外空间。

**更优解法**

注意到，如果当前位置为 $p$ ，从 $p$ 能够到达的最远位置为 $q$ ，那么假设在 $p$ 之前的所有位置均可到达，则从0至 $q$ 的所有位置都可到达。

因此，当前位置为0，能够到达的最远位置为 $r$ 时，从0到 $r$ 的所有位置都可到达。

进而可以得到，如果当前位置为 $p$，那么假设总是成立的。

故有：如果当前位置为 $p$ ，从 $p$ 能够到达的最远位置为 $q$，则从0至 $q$ 的所有位置都可到达。

显然，我们只需要维护最远可到达位置 $f$ 即可，如果有 $f \ge l$ ，$l$为目标位置，则可以到达，否则不可到达。

代码如下：

```c
int canJump(int* nums, int numsSize){
    int far=0;
    for(int i=0;i<numsSize;i++)
        if(i>far) return 0;
        else if(i+nums[i]>far)
            far=nums[i]+i;
    return 1;
}
```

时间复杂度为$O(n)$，只需要常数的额外空间。



## #56 合并区间

> [题目描述](https://leetcode.cn/problems/merge-intervals/)

典型的区间类问题，对于大部分的区间类问题，都需要进行排序，适用于本题的排序规则为：
$$
对于两个区间 \, I_{1}=\{l_{1}, \, r_{1}\} \, 和 \, I_{2}=\{l_{2}, \, r_{2}\} \\
优先按照l排序， 当l相等时，按照r倒序排列
$$
排序完成后，维护新区间的端点$N_{i}=\{ L_{i}, \, R_{i} \}$，然后按顺序检查每个区间 $I_{j} = \{ l_{j}, \, r_{j} \}$，当 $l_{j}>R_{i}$时，记录区间$N_{i}$，同时初始化下一个新区间 $N_{i+1} = \{ l_{j}, \, r_{j} \}$ ；否则，使$R_{i}=Max(R_{i}, \, r_{j})$。

复杂度为$O(n \cdot log_{2}n)$，其中$n$表示原始区间的数量。



## #61 旋转链表

> [题目描述](https://leetcode.cn/problems/rotate-list/)

先将链表首尾相连，构造出一个循环链表。

此时，将链表每个节点右移相当于将链表头向左移。

考虑到题目提供的链表为单向链表，不能直接进行左移，因此这里将左移转化为右移。

对于一个长度为 $l$ 的循环链表，将头部向左移 $k$ 次，相当于将头部右移 $l-k$ 次，这一部分代码如下：

```cpp
k%=len;
k=len-k;
for(int i=0;i<k;i++)
    head=head->next;
```

此时的`head`即为新链表的头部。

需要注意的是，最后需要断开循环，断开的位置是`head`的上一个节点，因此，在循环的过程中，我们还需要记录这个节点的位置。

复杂度为$O(l-m)$，其中$m \equiv k \pmod l$，可以更简洁地记为$O(l)$。

